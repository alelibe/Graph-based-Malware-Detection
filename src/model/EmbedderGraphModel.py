import torch
from torch import nn
from torch_geometric.data import Batch, Data
from Utils.vocabulary import Vocabulary
from torch.nn import functional as pt_f
from torch_geometric.nn.glob import global_max_pool, global_mean_pool
from torch_geometric.nn.conv import SAGEConv

class EmbedderGraphModel(nn.Module):
    def __init__(self,external_vocab: Vocabulary) -> None:
        super(EmbedderGraphModel,self).__init__()

        self.pool = "global_max_pool"
        if self.pool not in ["global_max_pool", "global_mean_pool"]:
            raise NotImplementedError

        #setting parameters for GraphSAGE for CFG
        cfg_filters = "200-200"
        if type(cfg_filters) == str:
            cfg_filter_list = [int(number_filter) for number_filter in cfg_filters.split("-")]
        else:
            cfg_filter_list = [int(cfg_filters)]

        cfg_filter_list.insert(0, 11)
        self.cfg_filter_length = len(cfg_filter_list)
        
        cfg_graphsage_params = [dict(in_channels=cfg_filter_list[i], out_channels=cfg_filter_list[i + 1], bias=True) for i in range(self.cfg_filter_length - 1)]  # GraphSAGE for cfg
        cfg_conv_layer_constructor = dict(kwargs=cfg_graphsage_params)
        
        for i in range(self.cfg_filter_length - 1):
            setattr(self, 'CFG_gnn_{}'.format(i + 1), SAGEConv(**cfg_conv_layer_constructor['kwargs'][i]))

        self.dropout = nn.Dropout(p=0.2)


        #setting parameters for GraphSAGE for FCG
        fcg_filters="200-200"
        self.external_embedding_layer = nn.Embedding(num_embeddings=external_vocab.max_vocab_size + 2, embedding_dim=cfg_filter_list[-1], padding_idx=external_vocab.pad_idx)
        if type(fcg_filters) == str:
            fcg_filter_list = [int(number_filter) for number_filter in fcg_filters.split("-")]
        else:
            fcg_filter_list = [int(fcg_filters)]
        
        fcg_filter_list.insert(0, cfg_filter_list[-1])
        self.fcg_filter_length = len(fcg_filter_list)
        
        fcg_graphsage_params = [dict(in_channels=fcg_filter_list[i], out_channels=fcg_filter_list[i + 1], bias=True) for i in range(self.fcg_filter_length - 1)]  # GraphSAGE for fcg
        fcg_conv_layer_constructor = dict(kwargs=fcg_graphsage_params)

        for i in range(self.fcg_filter_length - 1):
            setattr(self, 'FCG_gnn_{}'.format(i + 1), SAGEConv(**fcg_conv_layer_constructor['kwargs'][i]))


        self.lstm = nn.LSTM(input_size=fcg_filter_list[-1], hidden_size=100, num_layers=1, bidirectional=True)
        
        self.dense1 = nn.Linear(in_features=fcg_filter_list[-1], 
                                out_features=int(fcg_filter_list[-1] / 2))
        self.dense2 = nn.Linear(in_features=int(fcg_filter_list[-1] / 2), 
                                out_features=int(fcg_filter_list[-1] / 4))
        self.dense3 = nn.Linear(in_features=int(fcg_filter_list[-1] / 4), 
                                out_features=1)
        self.last_activation = nn.Sigmoid()
        

    def forward_cfg_gnn(self, local_batch: Batch):
        in_x, edge_index = local_batch.x, local_batch.edge_index
        for i in range(self.cfg_filter_length - 1):
            out_x = getattr(self, 'CFG_gnn_{}'.format(i + 1))(x=in_x, edge_index=edge_index)
            out_x = pt_f.relu(out_x, inplace=True)
            out_x = self.dropout(out_x)
            in_x = out_x
        local_batch.x = in_x
        return local_batch
    
    def aggregate_cfg_batch_pooling(self, local_batch: Batch):
        if self.pool == 'global_max_pool':
            x_pool = global_max_pool(x=local_batch.x, batch=local_batch.batch)
        elif self.pool == 'global_mean_pool':
            x_pool = global_mean_pool(x=local_batch.x, batch=local_batch.batch)
        else:
            raise NotImplementedError
        return x_pool
    
    def forward_fcg_gnn(self, function_batch: Batch):
        in_x, edge_index = function_batch.x, function_batch.edge_index
        for i in range(self.fcg_filter_length - 1):
            out_x = getattr(self, 'FCG_gnn_{}'.format(i + 1))(x=in_x, edge_index=edge_index)
            out_x = pt_f.relu(out_x, inplace=True)
            out_x = self.dropout(out_x)
            in_x = out_x
        function_batch.x = in_x
        return function_batch
    
    def aggregate_fcg_batch_pooling(self, function_batch: Batch):
        if self.pool == 'global_max_pool':
            x_pool = global_max_pool(x=function_batch.x, batch=function_batch.batch)
        elif self.pool == 'global_mean_pool':
            x_pool = global_mean_pool(x=function_batch.x, batch=function_batch.batch)
        else:
            raise NotImplementedError
        return x_pool
    
    def aggregate_final_skip_pooling(self, x, batch):
        if self.pool == 'global_max_pool':
            x_pool = global_max_pool(x=x, batch=batch)
        elif self.pool == 'global_mean_pool':
            x_pool = global_mean_pool(x=x, batch=batch)
        else:
            raise NotImplementedError
        return x_pool
    

    def forward(self,local_method_batch: Batch, local_bt_positions: list, bt_external_names: list, bt_all_method_edges,local_device: torch.device):
        acfg_local_batch = self.forward_cfg_gnn(local_batch=local_method_batch)
        x_cfg_pool = self.aggregate_cfg_batch_pooling(local_batch=acfg_local_batch)

        fcg_list = []
        fcg_internal_list = []
        for idx_batch in range(len(local_bt_positions) - 1):
            start_acfg_pos, end_acfg_pos = local_bt_positions[idx_batch: idx_batch + 2]
            
            idx_x_cfg = x_cfg_pool[start_acfg_pos: end_acfg_pos]
            fcg_internal_list.append(idx_x_cfg)
            
            idx_x_external = self.external_embedding_layer(torch.tensor([bt_external_names[idx_batch]], dtype=torch.long).to(local_device))
            idx_x_external = idx_x_external.squeeze(dim=0)
            
            idx_x_total = torch.cat([idx_x_cfg, idx_x_external], dim=0)
            idx_function_edge = torch.tensor(bt_all_method_edges[idx_batch], dtype=torch.long)
            idx_graph_data = Data(x=idx_x_total, edge_index=idx_function_edge).to(local_device)
            
            fcg_list.append(idx_graph_data)

        fcg_batch = Batch.from_data_list(fcg_list)

        rtn_fcg_batch = self.forward_fcg_gnn(function_batch=fcg_batch)  # [batch_size, max_node_size, dim]
        x_fcg_pool = self.aggregate_fcg_batch_pooling(function_batch=rtn_fcg_batch)  # [batch_size, 1, dim] => [batch_size, dim]
        # batch_final = x_fcg_pool
        # x = self.dense1(x_fcg_pool)
        # x = pt_f.relu(x)
        # x = self.dense2(x)
        # x = pt_f.relu(x)
        # x = self.dense3(x)
        # # bt_final_embed = self.pj3(self.pj2(self.pj1(batch_final)))
        # bt_pred = self.last_activation(x)

        # return bt_pred
        return x_fcg_pool

