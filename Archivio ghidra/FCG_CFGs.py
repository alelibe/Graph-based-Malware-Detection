#TODO write a description for this script
#@author 
#@category _NEW_
#@keybinding 
#@menupath 
#@toolbar 


from ghidra.program.model.block import BasicBlockModel
from ghidra.util.task import TaskMonitor
from ghidra.util.task import ConsoleTaskMonitor
import json
import os
import ghidra.app.script
import Utils


def createStatJson(path):
	stat = {
		"onClick": {"total": 0, "handled": 0},
		"startActivity": {"total": 0, "handled": 0},
		"startService": {"total": 0, "handled": 0},
		"switch": {"total": 0}
	}

	path = os.path.join(path, "statistics.json")
	with open(path, "w") as jsonFile:
    		json.dump(stat, jsonFile)

	return path
	

def createDir():
	appName = askString("App name", "Please type a name of app: ");
	parent_dir = "C:/Users/Alessia/Desktop/Unimi/Tesi/Ghidra_outputs/"
	dirName = appName + "/"
	path = os.path.join(parent_dir, dirName)
	pathFCG = os.path.join(path, "fcg.json")

	if not(os.path.exists(path)):
		os.mkdir(path)

	return pathFCG,path


def isFunction(fm,addr):
	bool = fm.isInFunction(addr)

	return bool

def get_jumpFrom(addr):
	refs = getReferencesFrom(addr)
	jump = refs[0]

	return jump

#prende tutti i receivers inseriti dall'utente
def takeReceivers(args):
	#lista dei broadcastReceivers
	receivers = []
	index = 0
	for idx, input in enumerate(args):
		if input == "r":
			index = idx+1

	if index != 0:
		while index < len(args):
			receivers.append(args[index])
			index = index + 1

	return receivers


def buildCFG(name,pathStat,pathOutput):
	bbm = BasicBlockModel(currentProgram)
	listing = currentProgram.getListing()
	monitor = ConsoleTaskMonitor()
	symTB = currentProgram.getSymbolTable()
        body = None

    	rindex = name.rindex("_")
        functionName = str(name[:rindex])
	symbols = symTB.getSymbols(functionName)
	while symbols.hasNext():
		sym = symbols.next()
		namespace = sym.getParentNamespace()
		print("nameSpace :" + str(namespace))
		className = Utils.parseNameSpace(str(namespace))
		print("ClassName :" + str(className))
		print("Name :" + str(name))
		if name in functionName + "_" + className:
			addr = sym.getAddress()
			f = listing.getFunctionAt(addr)
			if f != None:
				body = f.getBody()
				break

	if body == None:
		raise Exception("Body is None")

			

        nodes_cfg, edges_cfg = [], []
        disass = []
        bbs_dict = dict()


        blocks = bbm.getCodeBlocksContaining(body, monitor)

        block = blocks.next()
        block_prec_start = block.minAddress
        ins_prec = " "
        while block:
            listing = currentProgram.getListing()
            ins_iter = listing.getInstructions(block, True)
            
            block_start = block.minAddress
            nodes_cfg.append(str(block_start))
            if ("if" in str(ins_prec) and block_start != block_prec_start):
                edges_cfg.append((str(block_prec_start), str(block_start)))

            if not("if" in str(ins_prec) or "go" in str(ins_prec) or "return" in str(ins_prec)) and block_start != block_prec_start:
                edges_cfg.append((str(block_prec_start), str(block_start)))

            block_prec_start = block.minAddress
            

            ins = ins_iter.next()
            while ins:
                ins_prec = ins
                disass.append(str(ins))
                flows = ins.getFlows()
                if ("if" in str(ins) or "go" in str(ins)) and len(flows) == 1:
                    addrSucc = flows[0]
                    edges_cfg.append((str(block_start), str(addrSucc)))

                if "packed_switch" in str(ins):
                    Utils.updateStatTotal("switch",pathStat)
                    
                ins = ins_iter.next()
                
                
            bbs_dict[str(block_start)] = {'disass': disass}
            disass = []
            block = blocks.next()


        func_dict = {
                        'nodes': nodes_cfg,
                        'edges': edges_cfg,
                        'basic_blocks': bbs_dict
                    }
                    
        
        #filename = "C:/Users/Alessia/Desktop/Unimi/Tesi/Ghidra_outputs/howllarm/cfg_" + name + ".json"
        filename = "cfg_" + name + ".json"
        path2 = os.path.join(pathOutput,filename)
        with open(path2, "w") as outfile:
            json.dump(func_dict, outfile)
	    


def buildFCG(name, pathstat):
	listing = currentProgram.getListing()
	fm = currentProgram.getFunctionManager()
	symTB = currentProgram.getSymbolTable()
	body = None

	
	rindex = name.rindex("_")
        functionName = str(name[:rindex])
	print("FunctionName :" + functionName)
   	symbols = symTB.getSymbols(functionName)
	while symbols.hasNext():
		sym = symbols.next()
		namespace = sym.getParentNamespace()
		print("nameSpace :" + str(namespace))
		className = Utils.parseNameSpace(str(namespace))
		print("ClassName :" + str(className))
		print("Name :" + str(name))
		if name in functionName + "_" + className:
			addr = sym.getAddress()
			f = listing.getFunctionAt(addr)
			if f != None:
				body = f.getBody()
				break

	if body == None:
		raise Exception("Body is None")

	
	ins_iter = listing.getInstructions(body, True)
		
	
	while ins_iter.hasNext():
		ins = ins_iter.next()
		if "invoke" in str(ins):
			addr_toJump = get_jumpFrom(ins.getAddress()).getToAddress()
			if isFunction(fm,addr_toJump):
				methodName = str(fm.getFunctionAt(addr_toJump))
			else:
				methodName = str(get_jumpFrom(addr_toJump))[2:]
		
			
			if not("EXT" in methodName):
				methodName = Utils.parseNameSpace(methodName,True)
								
			if not(methodName in nodes_fcg):
				nodes_fcg.append(methodName)
				
			
			edges_fcg.append((name, methodName))
			
			#checkLinks(methodName,ins)
			detect = Utils.DetectIns(ins,methodName,edges_fcg,nodes_fcg,pathStat)
			detect.detect()

			
# creo l'insieme di nodi e di archi
nodes_fcg, edges_fcg = [], []

already_analyze = []

#args = getScriptArgs()
pathFCG,path = createDir()
pathStat = createStatJson(path)


mainMethod = askString("Main method's name", "Please type a name of main method: ");
#mainMethod = args[1]
name = "onCreate" + "_" + mainMethod
buildFCG(name,pathStat)
nodes_fcg.append(name)
already_analyze.append(name)



i = 0
method_class = str(edges_fcg[0][0])
while i < len(edges_fcg):
	#espando il grafo prendendo in considerazione i metodi chiamati dal metodo in esame
	if (method_class in str(edges_fcg[i][0])) and not("EXTERNAL" in edges_fcg[i][1]):
		#node = edges_fcg[i][1].split("::")[-1]
		node = edges_fcg[i][1]
		if not(node in already_analyze):
			buildFCG(node,pathStat)
			already_analyze.append(node)

	if not(method_class in str(edges_fcg[i][0])):
		method_class = edges_fcg[i][0].split("::")[-1]
	else:
		i = i + 1
	
fcg_dict = {
                'nodes': nodes_fcg,
                'edges': edges_fcg
            }
             
with open(pathFCG, "w") as outfile:
    json.dump(fcg_dict, outfile)



#per i metodi che non sono esterni costruisco il CFG
for node in nodes_fcg:
	if not("EXT" in node):
		buildCFG(node,pathStat,path)
