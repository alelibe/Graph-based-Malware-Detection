#TODO write a description for this script
#@author 
#@category _NEW_
#@keybinding 
#@menupath 
#@toolbar 

from __main__ import currentProgram
import json

#concatenate = False --> restuisco il nome della classe a cui appartiene il metodo
#concatenate = True --> concateno metodo_classe
def parseNameSpace(namespace, concatenate = False, sep = "_"):
	if not(concatenate):
		className = namespace.split("::")[-1]
		end_index = className.find(" ")
		return className[:end_index]
	else:
		splitName = namespace.split("::")
		return splitName[-1] + sep + splitName[-2]
	
#True if node_activity exists in the list of functions
#it's necessary because sometimes a service doesn't have the onStartCommand method or onCreate method
def checkMethodExists(node_activity):
	symTB = currentProgram.getSymbolTable()
	rindex = node_activity.rindex("_")
	methodName = str(node_activity[:rindex])
	symbols = symTB.getSymbols(methodName)
	while symbols.hasNext():
		sym = symbols.next()
		namespace = sym.getParentNamespace()
		className = parseNameSpace(str(namespace))
		if node_activity in methodName + className:
			return True
		
	return False

def updateStatHandled(methodName,pathStat):
	with open(pathStat,'r') as f:
		data = json.load(f)

	if "startActivity" in methodName:
		data["startActivity"]["handled"] += 1
	
	if "startService" in methodName:
		data["startService"]["handled"] += 1
	
	if "setOnClickListener" in methodName:
		data["onClick"]["handled"] += 1


	with open(pathStat, "w") as jsonFile:
			json.dump(data, jsonFile)


def updateStatTotal(methodName,pathStat):
	with open(pathStat,'r') as f:
		data = json.load(f)

	if "startActivity" in methodName:
		data["startActivity"]["total"] += 1

	if "startService" in methodName:
		data["startService"]["total"] += 1

	if "setOnClickListener" in methodName:
		data["onClick"]["total"] += 1
	
	if "switch" in methodName:
		data["switch"]["total"] += 1

	with open(pathStat, "w") as jsonFile:
			json.dump(data, jsonFile)


class SolveLinks:
	
	def solve(self,ins,methodName,edges_fcg,nodes_fcg):
		pass


class Listener(SolveLinks):

	def solve(self,ins,methodName,edges_fcg,nodes_fcg,pathStat):
		#es: invoke_virtual 0x7,v1,v2. Prendo v2 che mi indica
		#il registro in cui si trova la classe che contiene l'interfaccia di riferimento
		reg_invoke_virtual = ins.getRegister(2).getName()

		reg_invoke_direct = ""
		while not(reg_invoke_virtual == reg_invoke_direct):
			ins = ins.getPrevious()
			if "invoke_direct" in str(ins):
				addr = ins.getAddress()
				reg_invoke_direct = ins.getRegister(1)

				if reg_invoke_direct != None:
					reg_invoke_direct = reg_invoke_direct.getName()
					new_ins = ins

		new_ins = new_ins.getPrevious()
		if "new_instance" in str(new_ins):
			addr = new_ins.getAddress()

			equateTable = currentProgram.getEquateTable()
			pathClass = str(equateTable.getEquates(addr,1)[0]).split("/")[-1]
			end_index = pathClass.find(";")
			classMethod = pathClass[:end_index]

			node = ""
			if "setOnClickListener" in methodName:
				node = "onClick" + "_" + classMethod
				

			if checkMethodExists(node):
				if not(node in nodes_fcg):
					nodes_fcg.append(node_activity)

				edges_fcg.append((methodName, node_activity))
			
			# if not(node in nodes_fcg):
			# 	nodes_fcg.append(node)
		
			# edges_fcg.append((methodName, node))

			updateStatHandled(methodName,pathStat)

		updateStatTotal(methodName,pathStat)




# class Listener(SolveLinks):

# 	def solve(self,ins,methodName,edges_fcg,nodes_fcg):
# 		#es: invoke_virtual 0x7,v1,v2. Prendo v2 che mi indica
# 		#il registro in cui si trova la classe che contiene l'interfaccia di riferimento
# 		reg_invoke = ins.getRegister(2).getName()
	
# 		reg_newIstance = " "
# 		while not(reg_invoke == reg_newIstance):
# 			ins = ins.getPrevious()
# 			if "new_instance" in str(ins):
# 				reg_newIstance = ins.getRegister(0).getName()
# 				addr = ins.getAddress()

# 		addr = addr.getPrevious()
		

# 		equateTable = currentProgram.getEquateTable()
# 		pathClass = str(equateTable.getEquates(addr,1)[0]).split("/")[-1]
# 		end_index = pathClass.find(";")
# 		classMethod = pathClass[:end_index]

# 		node = ""
# 		if "setOnClickListener" in methodName:
# 			node = "onClick" + "_" + classMethod

# 		# if "setOnNavigationItemSelectedListener" in methodName:
# 		# 	node = "onNavigationItemSelected" + "_" + classMethod
		 	
#  		if not(node in nodes_fcg):
# 			nodes_fcg.append(node)
 	
#  		edges_fcg.append((methodName, node))

		
# class StartActivity(SolveLinks):

# 	def solve(self,ins,methodName,edges_fcg,nodes_fcg):
# 		while not("const_class" in str(ins)):
# 			ins = ins.getPrevious()
# 			addr = ins.getAddress()
	
# 		equateTable = currentProgram.getEquateTable()
# 		pathActivity = str(equateTable.getEquates(addr,1)[0]).split("/")[-1]
# 		end_index = pathActivity.find(";")
# 		activity = pathActivity[:end_index]

# 		node_activity = "onCreate" + "_" + activity

# 		if not(node_activity in nodes_fcg):
#  			nodes_fcg.append(node_activity)

#  		edges_fcg.append((methodName, node_activity))



class Start(SolveLinks):
	def solve(self,ins,methodName,edges_fcg,nodes_fcg,pathStat):
		reg_invoke_virtual = ins.getRegister(2).getName()
		reg_invoke_direct = ""
		
		while not(reg_invoke_virtual == reg_invoke_direct):
			ins = ins.getPrevious()
			if "invoke_direct" in str(ins):
				addr = ins.getAddress()
				reg_invoke_direct = ins.getRegister(1)
				
				if reg_invoke_direct != None:
					reg_invoke_direct = reg_invoke_direct.getName()
					new_ins = ins

		
		reg_invoke_direct = new_ins.getRegister(3)
		if reg_invoke_direct != None:
			reg_invoke_direct = reg_invoke_direct.getName()
			reg_const_class = ""
			new_ins = new_ins.getPrevious()
			if "const_class" in str(new_ins):
				reg_const_class = new_ins.getRegister(0).getName()
				if(reg_invoke_direct == reg_const_class):
					addr = new_ins.getAddress()

					equateTable = currentProgram.getEquateTable()
					pathActivity = str(equateTable.getEquates(addr,1)[0]).split("/")[-1]
					end_index = pathActivity.find(";")
					activity = pathActivity[:end_index]

					node_activity = "onCreate" + "_" + activity


					if checkMethodExists(node_activity):
						if not(node_activity in nodes_fcg):
							nodes_fcg.append(node_activity)

						edges_fcg.append((methodName, node_activity))


					# if "startService" in methodName:
					# 	node_activity = "onStartCommand" + "_" + activity
					# 	if not(node_activity in nodes_fcg):
					# 		nodes_fcg.append(node_activity)

					# 	edges_fcg.append((methodName, node_activity))

					
					if "startService" in methodName:
						node_activity = "onStartCommand_" + activity
						if checkMethodExists(node_activity):
							if not(node_activity in nodes_fcg):
									nodes_fcg.append(node_activity)

							edges_fcg.append((methodName, node_activity))
					

					updateStatHandled(methodName,pathStat)
			
		updateStatTotal(methodName,pathStat)

# class Start(SolveLinks):

# 	def solve(self,ins,methodName,edges_fcg,nodes_fcg):
# 		reg_invoke_virtual = ins.getRegister(1).getName()
# 		reg_invoke_direct = ""
		
# 		while not(reg_invoke_virtual == reg_invoke_direct):
# 			ins = ins.getPrevious()
# 			if "invoke_direct" in str(ins):
# 				addr = ins.getAddress()
# 				reg_invoke_direct = ins.getRegister(2)
				
# 				if reg_invoke_direct != None:
# 					reg_invoke_direct = reg_invoke_direct.getName()
# 					new_ins = ins

# 		reg_invoke_direct = new_ins.getRegister(3).getName()
# 		reg_const_class = ""
# 		while not(reg_invoke_direct == reg_const_class):
# 			new_ins = new_ins.getPrevious()
# 			if "const_class" in str(new_ins):
# 				reg_const_class = new_ins.getRegister(0).getName()
# 				addr = new_ins.getAddress()

# 		equateTable = currentProgram.getEquateTable()
# 		pathActivity = str(equateTable.getEquates(addr,1)[0]).split("/")[-1]
# 		end_index = pathActivity.find(";")
# 		activity = pathActivity[:end_index]

# 		node_activity = "onCreate" + "_" + activity

# 		if not(node_activity in nodes_fcg):
#  			nodes_fcg.append(node_activity)

#  		edges_fcg.append((methodName, node_activity))



#  		if "Service" in methodName:
#  			node_activity = "onStartCommand" + "_" + activity
#  			if not(node_activity in nodes_fcg):
#  				nodes_fcg.append(node_activity)

#  			edges_fcg.append((methodName, node_activity))

 


class DetectIns:
	
	def __init__(self,ins,methodName,edges_fcg,nodes_fcg,pathStat):
		self.ins = ins
		self.methodName = methodName
		self.edges_fcg = edges_fcg
		self.nodes_fcg = nodes_fcg
		self.pathStat = pathStat
		

	def detect(self):
		if "EXT" in self.methodName and ("setOnClickListener" in self.methodName):

			solveLink = Listener()
			solveLink.solve(self.ins,self.methodName,self.edges_fcg,self.nodes_fcg,self.pathStat)
			#linkOnclick(methodName,ins)
				

		# if "EXT" in self.methodName and ("startActivity" in self.methodName or "startService" in self.methodName or 
		# 	"startForegroundService" in self.methodName):
		if "EXT" in self.methodName and ("startActivity" in self.methodName or 
		"startService" in self.methodName):
			#linkActivity(methodName,ins)
			solveLink = Start()
			solveLink.solve(self.ins,self.methodName,self.edges_fcg,self.nodes_fcg,self.pathStat)

