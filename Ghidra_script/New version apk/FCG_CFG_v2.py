#TODO write a description for this script
#@author 
#@category _NEW_
#@keybinding 
#@menupath 
#@toolbar 

from ghidra.program.model.block import BasicBlockModel
from ghidra.util.task import TaskMonitor
from ghidra.util.task import ConsoleTaskMonitor
import json


#concatenate = False --> restuisco il nome della classe a cui appartiene il metodo
#concatenate = True --> concateno metodo_classe
def parseNameSpace(namespace, concatenate = False, sep = "_"):
	if not(concatenate):
		className = namespace.split("::")[-1]
		end_index = className.find(" ")
		return className[:end_index]
	else:
		splitName = namespace.split("::")
		return splitName[-1] + sep + splitName[-2]


def buildCFG(name):
	bbm = BasicBlockModel(currentProgram)
	monitor = ConsoleTaskMonitor()
	
	
	body = None
	funcs = currentProgram.getFunctionManager().getFunctions(True)
	for f in funcs:
		nameSpace = str(f.getParentNamespace())
		className = parseNameSpace(nameSpace)
		functionName = str(f.getName()) 
		if name in functionName + "_" + className:
			body = f.getBody()
			

	# creo l'insieme di nodi e di archi
	nodes_cfg, edges_cfg = [], []
	# creo la lista che conterrà l'assembly del blocco
	disass = []
	# basic block's features
	bbs_dict = dict()

	if body == None:
		raise Exception("Body is None")

	blocks = bbm.getCodeBlocksContaining(body, monitor)

	block = blocks.next()
	#memorizzo l'inizio del blocco precedente
	block_prec_start = block.minAddress
	ins_prec = " "
	while block:
		listing = currentProgram.getListing()
	    	ins_iter = listing.getInstructions(block, True)
		
		block_start = block.minAddress
		nodes_cfg.append(str(block_start))
		if ("if" in str(ins_prec) and block_start != block_prec_start):
			edges_cfg.append((str(block_prec_start), str(block_start)))

		if not("if" in str(ins_prec) or "go" in str(ins_prec) or "return" in str(ins_prec)) and block_start != block_prec_start:
			edges_cfg.append((str(block_prec_start), str(block_start)))

		block_prec_start = block.minAddress
		

		ins = ins_iter.next()
		while ins:
			ins_prec = ins
			disass.append(str(ins))
			flows = ins.getFlows()
			if ("if" in str(ins) or "go" in str(ins)) and len(flows) == 1:
				addrSucc = flows[0]
				edges_cfg.append((str(block_start), str(addrSucc)))
				
		   	ins = ins_iter.next()
			
			
		bbs_dict[str(block_start)] = {'disass': disass}
		disass = []
		block = blocks.next()


	func_dict = {
	                'nodes': nodes_cfg,
	                'edges': edges_cfg,
	                'basic_blocks': bbs_dict
	            }
	             
	filename = "C:/Users/Alessia/Desktop/Unimi/Tesi/Ghidra_outputs/cfg_" + name + ".json"
	with open(filename, "w") as outfile:
	    json.dump(func_dict, outfile)




def isFunction(fm,addr):
	bool = fm.isInFunction(addr)

	return bool

def get_jumpFrom(addr):
	refs = getReferencesFrom(addr)
	jump = refs[0]

	return jump



#controlla se c'è bisogno di aggiungere un link per alcuni metodi esterni chiamati 
def checkLinks(methodName, method_prec,ins):
	if "EXT" in methodName and "Listener" in methodName:
		class_method_prec = method_prec.split("_")[-1]
		methodName = methodName + "_" + class_method_prec
		linkOnclick(methodName,class_method_prec)
				

	if "EXT" in methodName and "startActivity" in methodName:
		linkActivity(methodName,ins)
		
	

#collega il metodo esterno setOnClickListener al metodo onClick corrispondente
def linkOnclick(methodName, classMethod):
	onclick_method = "onClick_" + classMethod
			 	
 	if not(onclick_method in nodes_fcg):
 		nodes_fcg.append(onclick_method)
 	
 	edges_fcg.append((methodName, onclick_method))


#collega il metodo esterno startActivity al metodo onCreate dell'activity corretta
def linkActivity(methodName,ins):
	while not("const_class" in str(ins)):
		ins = ins.getPrevious()
		addr = ins.getAddress()
	


	# equateTable gestisce gli equate del programma.
	# un equate definisce una relazione tra un valore scalare e una stringa in modo che lo scalare può essere rappresentato dalla stringa.
	# Mi serve per recuperare il nome dell'activity che viene chiamata
	equateTable = currentProgram.getEquateTable()
	pathActivity = str(equateTable.getEquates(addr,1)[0]).split("/")[-1]
	end_index = pathActivity.find(";")
	activity = pathActivity[:end_index]

	node_activity = "onCreate" + "_" + activity

	if not(node_activity in nodes_fcg):
 		nodes_fcg.append(node_activity)

 	edges_fcg.append((methodName, node_activity))



def buildFCG(name, bodyMethod = None):
	listing = currentProgram.getListing()
	fm = currentProgram.getFunctionManager()
	if not("onCreate" in name):
		funcs = fm.getFunctions(True)
		for f in funcs:
			nameSpace = str(f.getParentNamespace())
			className = parseNameSpace(nameSpace)
			functionName = str(f.getName()) 
			if name in functionName + "_" + className:
				body = f.getBody()
				break

		
	else:
		body = bodyMethod
		className = name.split("_")[-1]

	ins_iter = listing.getInstructions(body, True)
		
	method_prec = " "
	while ins_iter.hasNext():
		ins = ins_iter.next()
		if "invoke" in str(ins):
			addr_toJump = get_jumpFrom(ins.getAddress()).getToAddress()
			if isFunction(fm,addr_toJump):
				methodName = str(fm.getFunctionAt(addr_toJump))
			else:
				methodName = str(get_jumpFrom(addr_toJump))[2:]
		
			
			if not("EXT" in methodName):
				methodName = parseNameSpace(methodName,True)

								
			if not(methodName in nodes_fcg):
				nodes_fcg.append(methodName)

			edges_fcg.append((name, methodName))

			checkLinks(methodName,method_prec,ins)
			method_prec = methodName	

			
# creo l'insieme di nodi e di archi per il fcg
nodes_fcg, edges_fcg = [], []


fm = currentProgram.getFunctionManager()
funcs = fm.getFunctions(True)
for f in funcs:
	# costruisco il FCG partendo dalle onCreate
	if "onCreate" in str(f.getName()):
		#param prende il primo parametro dell'onCreate che corrisponde all'activity di riferimento
		param = str(f.getParameters()[0])[1:].split("*")[0]
		method_class = "onCreate" + "_" + param[:-1]
		
		#if "Main" in param:
		#print param
		onCreate_body = f.getBody()
		nodes_fcg.append(method_class)

		buildFCG(method_class,onCreate_body)	

i = 0
method_class = str(edges_fcg[0][0])
while i < len(edges_fcg):
	#espando il grafo prendendo in considerazione i metodi chiamati dal metodo in esame
	if (method_class in str(edges_fcg[i][0])) and not("EXTERNAL" in edges_fcg[i][1]):
		if not("onCreate" in edges_fcg[i][1]):
			#node = edges_fcg[i][1].split("::")[-1]
			node = edges_fcg[i][1]
			buildFCG(node)

	if not(method_class in str(edges_fcg[i][0])):
		method_class = edges_fcg[i][0].split("::")[-1]
	else:
		i = i + 1
	
#per i metodi che non sono esterni costruisco il CFG
for node in nodes_fcg:
	if not("EXT" in node):
		name = node.split("::")[-1]
		buildCFG(name)

fcg_dict = {
                'nodes': nodes_fcg,
                'edges': edges_fcg
            }
             
with open("C:/Users/Alessia/Desktop/Unimi/Tesi/Ghidra_outputs/fcg_test2.json", "w") as outfile:
    json.dump(fcg_dict, outfile)
