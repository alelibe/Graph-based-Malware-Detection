#TODO write a description for this script
#@author 
#@category _NEW_
#@keybinding 
#@menupath 
#@toolbar 

from __main__ import currentProgram

class SolveLinks:
	
	def solve(self,ins,methodName,edges_fcg,nodes_fcg):
		pass

class OnClick(SolveLinks):

	def solve(self,ins,methodName,edges_fcg,nodes_fcg):
		#es: invoke_virtual 0x7,v1,v2. Prendo v2 che mi indica
		#il registro in cui sta la classe ViewOnClickListener
		reg_invoke = ins.getRegister(2).getName()
	
		reg_newIstance = " "
		while not(reg_invoke == reg_newIstance):
			ins = ins.getPrevious()
			if "new_instance" in str(ins):
				reg_newIstance = ins.getRegister(0).getName()
				addr = ins.getAddress()
		
		equateTable = currentProgram.getEquateTable()
		pathClass = str(equateTable.getEquates(addr,1)[0]).split("/")[-1]
		end_index = pathClass.find(";")
		classMethod = pathClass[:end_index]

		onclick_method = "onClick" + "_" + classMethod
		 	
 		if not(onclick_method in nodes_fcg):
 			nodes_fcg.append(onclick_method)
 	
 		edges_fcg.append((methodName, onclick_method))

		
# class StartActivity(SolveLinks):

# 	def solve(self,ins,methodName,edges_fcg,nodes_fcg):
# 		while not("const_class" in str(ins)):
# 			ins = ins.getPrevious()
# 			addr = ins.getAddress()
	
# 		equateTable = currentProgram.getEquateTable()
# 		pathActivity = str(equateTable.getEquates(addr,1)[0]).split("/")[-1]
# 		end_index = pathActivity.find(";")
# 		activity = pathActivity[:end_index]

# 		node_activity = "onCreate" + "_" + activity

# 		if not(node_activity in nodes_fcg):
#  			nodes_fcg.append(node_activity)

#  		edges_fcg.append((methodName, node_activity))


class Start(SolveLinks):

	def solve(self,ins,methodName,edges_fcg,nodes_fcg):
		reg_invoke_virtual = ins.getRegister(1).getName()
		reg_invoke_direct = ""
		
		while not(reg_invoke_virtual == reg_invoke_direct):
			ins = ins.getPrevious()
			if "invoke_direct" in str(ins):
				addr = ins.getAddress()
				print ins, addr
				reg_invoke_direct = ins.getRegister(2)
				#perch√® ci possono essere invoke_direct che hanno
				#solo 2 argomenti invece di 4, quindi controllo che
				#ce ne siano 4 e che quindi ins.getRegister(2) funzioni
				if reg_invoke_direct != None:
					reg_invoke_direct = reg_invoke_direct.getName()
					new_ins = ins

		reg_invoke_direct = new_ins.getRegister(3).getName()
		reg_const_class = ""
		while not(reg_invoke_direct == reg_const_class):
			new_ins = new_ins.getPrevious()
			if "const_class" in str(new_ins):
				reg_const_class = new_ins.getRegister(0).getName()
				addr = new_ins.getAddress()

		equateTable = currentProgram.getEquateTable()
		pathActivity = str(equateTable.getEquates(addr,1)[0]).split("/")[-1]
		end_index = pathActivity.find(";")
		activity = pathActivity[:end_index]

		node_activity = "onCreate" + "_" + activity

		if not(node_activity in nodes_fcg):
 			nodes_fcg.append(node_activity)

 		edges_fcg.append((methodName, node_activity))

 


class DetectIns:
	
	def __init__(self,ins,methodName,edges_fcg,nodes_fcg):
		self.ins = ins
		self.methodName = methodName
		self.edges_fcg = edges_fcg
		self.nodes_fcg = nodes_fcg
		

	def detect(self):
		if "EXT" in self.methodName and "setOnClickListener" in self.methodName:
			solveLink = OnClick()
			solveLink.solve(self.ins,self.methodName,self.edges_fcg,self.nodes_fcg)
			#linkOnclick(methodName,ins)
				

		if "EXT" in self.methodName and "startActivity" in self.methodName:
			#linkActivity(methodName,ins)
			solveLink = Start()
			solveLink.solve(self.ins,self.methodName,self.edges_fcg,self.nodes_fcg)

