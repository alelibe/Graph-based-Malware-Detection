#TODO write a description for this script
#@author 
#@category _NEW_
#@keybinding 
#@menupath 
#@toolbar 

from ghidra.program.model.block import BasicBlockModel
from ghidra.util.task import TaskMonitor
from ghidra.util.task import ConsoleTaskMonitor
import json
import os
import ghidra.app.script
import Utils

#concatenate = False --> restuisco il nome della classe a cui appartiene il metodo
#concatenate = True --> concateno metodo_classe
def parseNameSpace(namespace, concatenate = False, sep = "_"):
	if not(concatenate):
		className = namespace.split("::")[-1]
		end_index = className.find(" ")
		return className[:end_index]
	else:
		splitName = namespace.split("::")
		return splitName[-1] + sep + splitName[-2]


def createDir(args):
	#appName = askString("App name", "Please type a name of app: ");
	parent_dir = "C:/Users/Alessia/Desktop/Unimi/Tesi/Ghidra_outputs/"
	dirName = args[0] + "/"
	path = os.path.join(parent_dir, dirName)
	pathFCG = os.path.join(path, "fcg.json")

	if not(os.path.exists(path)):
		os.mkdir(path)

	return pathFCG


def isFunction(fm,addr):
	bool = fm.isInFunction(addr)

	return bool

def get_jumpFrom(addr):
	refs = getReferencesFrom(addr)
	jump = refs[0]

	return jump

#prende tutti i receivers inseriti dall'utente
def takeReceivers(args):
	#lista dei broadcastReceivers
	receivers = []
	for idx, input in enumerate(args):
		if input == "r":
			index = idx+1

	while index < len(args):
		receivers.append(args[index])
		index = index + 1

	return receivers


def buildFCG(name, bodyMethod = None):
	listing = currentProgram.getListing()
	fm = currentProgram.getFunctionManager()
	
	body = None
	funcs = fm.getFunctions(True)
	for f in funcs:
		nameSpace = str(f.getParentNamespace())
		className = parseNameSpace(nameSpace)
		functionName = str(f.getName()) 
		if name in functionName + "_" + className:
			body = f.getBody()
			break

	if body == None:
		raise Exception("Body is None")

	ins_iter = listing.getInstructions(body, True)
		
	
	while ins_iter.hasNext():
		ins = ins_iter.next()
		if "invoke" in str(ins):
			addr_toJump = get_jumpFrom(ins.getAddress()).getToAddress()
			if isFunction(fm,addr_toJump):
				methodName = str(fm.getFunctionAt(addr_toJump))
			else:
				methodName = str(get_jumpFrom(addr_toJump))[2:]
		
			
			if not("EXT" in methodName):
				methodName = parseNameSpace(methodName,True)
								
			if not(methodName in nodes_fcg):
				nodes_fcg.append(methodName)
				
			
			edges_fcg.append((name, methodName))
			
			#checkLinks(methodName,ins)
			detect = Utils.DetectIns(ins,methodName,edges_fcg,nodes_fcg)
			detect.detect()

			
# creo l'insieme di nodi e di archi
nodes_fcg, edges_fcg = [], []
# creo la lista che conterrà i nodi già esplorati
already_analyze = []

args = getScriptArgs()
pathFCG = createDir(args)


#mainMethod = askString("Main method's name", "Please type a name of main method: ");
mainMethod = args[1]
name = "onCreate" + "_" + mainMethod
buildFCG(name)
nodes_fcg.append(name)
already_analyze.append(name)

receivers = takeReceivers(args)
for rec in receivers:
	name = "onReceive" + "_" + rec
	buildFCG(name)
	nodes_fcg.append(name)
	already_analyze.append(name)


i = 0
method_class = str(edges_fcg[0][0])
while i < len(edges_fcg):
	#espando il grafo prendendo in considerazione i metodi chiamati dal metodo in esame
	if (method_class in str(edges_fcg[i][0])) and not("EXTERNAL" in edges_fcg[i][1]):
		#node = edges_fcg[i][1].split("::")[-1]
		node = edges_fcg[i][1]
		# se non l'ho esplorato allora lo visito per continuare a espandere il grafo
		if not(node in already_analyze):
			buildFCG(node)
			already_analyze.append(node)

	if not(method_class in str(edges_fcg[i][0])):
		method_class = edges_fcg[i][0].split("::")[-1]
	else:
		i = i + 1
	
fcg_dict = {
                'nodes': nodes_fcg,
                'edges': edges_fcg
            }
             
with open(pathFCG, "w") as outfile:
    json.dump(fcg_dict, outfile)

