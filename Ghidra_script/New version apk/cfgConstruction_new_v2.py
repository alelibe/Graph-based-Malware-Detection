#TODO scorre tutte le funzioni che trova e per ognuna costruisce il CFG. Per ricordarmi a che classe appartiene a un metodo, ogni meotodo
#lo nomico come method_classname. Il problema è se ho due metodi chiamati allo stesso modo che appartengo alla stessa classe perchè
#in questo caso costruisco il CFG solo di una. RISOLVERE
#@author 
#@category _NEW_
#@keybinding 
#@menupath 

from ghidra.program.model.block import BasicBlockModel
from ghidra.util.task import TaskMonitor
from ghidra.util.task import ConsoleTaskMonitor
from ghidra.util.graph import Edge
from ghidra.util.graph import Vertex
import json
import os

def parseNameSpace(namespace, concatenate = False, sep = "_"):
	if not(concatenate):
		className = namespace.split("::")[-1]
		end_index = className.find(" ")
		return className[:end_index]
	else:
		splitName = namespace.split("::")
		return splitName[-1] + sep + splitName[-2]


def buildCFG(name):
	bbm = BasicBlockModel(currentProgram)
	monitor = ConsoleTaskMonitor()
	
	
	body = None
	funcs = currentProgram.getFunctionManager().getFunctions(True)
	for f in funcs:
		nameSpace = str(f.getParentNamespace())
		className = parseNameSpace(nameSpace)
		functionName = str(f.getName()) 
		if name in functionName + "_" + className:
			body = f.getBody()
			
	
	nodes_cfg, edges_cfg = [], []
	disass = []
	bbs_dict = dict()

	if body == None:
		raise Exception("Body is None")

	blocks = bbm.getCodeBlocksContaining(body, monitor)

	block = blocks.next()
	block_prec_start = block.minAddress
	ins_prec = " "
	while block:
		listing = currentProgram.getListing()
	    	ins_iter = listing.getInstructions(block, True)
		
		block_start = block.minAddress
		nodes_cfg.append(str(block_start))
		if ("if" in str(ins_prec) and block_start != block_prec_start):
			edges_cfg.append((str(block_prec_start), str(block_start)))

		if not("if" in str(ins_prec) or "go" in str(ins_prec) or "return" in str(ins_prec)) and block_start != block_prec_start:
			edges_cfg.append((str(block_prec_start), str(block_start)))

		block_prec_start = block.minAddress
		

		ins = ins_iter.next()
		while ins:
			ins_prec = ins
			disass.append(str(ins))
			flows = ins.getFlows()
			if ("if" in str(ins) or "go" in str(ins)) and len(flows) == 1:
				addrSucc = flows[0]
				edges_cfg.append((str(block_start), str(addrSucc)))
				
		   	ins = ins_iter.next()
			
			
		bbs_dict[str(block_start)] = {'disass': disass}
		disass = []
		block = blocks.next()


	func_dict = {
	                'nodes': nodes_cfg,
	                'edges': edges_cfg,
	                'basic_blocks': bbs_dict
	            }
	             
	
	#filename = "C:/Users/Alessia/Desktop/Unimi/Tesi/Ghidra_outputs/howllarm/cfg_" + name + ".json"
	filename = "cfg_" + name + ".json"
	#path che contiene anche il nome del file da creare
	cfgOutput = os.path.join(path,filename)
	with open(cfgOutput, "w") as outfile:
	    json.dump(func_dict, outfile)


appName = askString("App name", "Please type a name of the app: ");
#è la directory che conterrà gli output dei vari apk
parent_dir = "C:/Users/Alessia/Desktop/Unimi/Tesi/Ghidra_outputs/"
#la cartella che conterrà i cfg, specifica per l'apk corrente
dirName = appName + "/"
path = os.path.join(parent_dir, dirName)

if not(os.path.exists(path)):
	os.mkdir(path)

fm = currentProgram.getFunctionManager()
funcs = fm.getFunctions(True)
for f in funcs:
	nameSpace = str(f.getParentNamespace())
	#in questo modo considero solo le funzioni dell'app e non quelle esterne
	#proprie di android
	if not("android" in nameSpace):
		className = parseNameSpace(nameSpace)
		functionName = str(f.getName()) 
		name = functionName + "_" + className
		buildCFG(name)
