#TODO write a description for this script
#@author 
#@category _NEW_
#@keybinding 
#@menupath 

from ghidra.program.model.block import BasicBlockModel
from ghidra.util.task import TaskMonitor
from ghidra.util.task import ConsoleTaskMonitor
from ghidra.util.graph import Edge
from ghidra.util.graph import Vertex
import json


bbm = BasicBlockModel(currentProgram)
monitor = ConsoleTaskMonitor()

funcs = currentProgram.getFunctionManager().getFunctions(True)
for f in funcs:
	if "onCreate" in str(f.getName()):
		body = f.getBody()


# creo l'insieme di nodi e di archi
nodes_list, edges_list = [], []
disass = []
# basic block's features
bbs_dict = dict()

blocks = bbm.getCodeBlocksContaining(body, monitor)

block = blocks.next()
#memorizzo l'inizio del blocco precedente
block_prec_start = block.minAddress
ins_prec = " "
while block:
	listing = currentProgram.getListing()
    ins_iter = listing.getInstructions(block, True)

  	block_start = block.minAddress
	nodes_list.append(str(block_start))
	if ("if" in str(ins_prec) and block_start != block_prec_start):
		edges_list.append((str(block_prec_start), str(block_start)))

	#seconda condizione serve perchè al primo giro block_start è uguale a block_prec_start
	#e questo significa che ins_prec è ancora uguale a " "
	if not("if" in str(ins_prec) or "go" in str(ins_prec) or "return" in str(ins_prec)) and block_start != block_prec_start:
		edges_list.append((str(block_prec_start), str(block_start)))

	block_prec_start = block.minAddress
	

	# metto l'assemby del blocco in un dict
	#bbs_dict[str(block_start)] = {'disass': disassembly_block(block)}

	ins = ins_iter.next()
	while ins:
		ins_prec = ins
		disass.append(str(ins))
		flows = ins.getFlows()
		print ins
		print flows
		if ("if" in str(ins) or "go" in str(ins)) and len(flows) == 1:
			addrSucc = flows[0]
			edges_list.append((str(block_start), str(addrSucc)))
			# print "0x{}".format(flows[0])
				# if ins.getAddressString(False, True) == addr :
				# 	print addr

	   	ins = ins_iter.next()
		
		
	bbs_dict[str(block_start)] = {'disass': disass}
	disass = []
	block = blocks.next()
	

func_dict = {
                'nodes': nodes_list,
                'edges': edges_list,
                'basic_blocks': bbs_dict
            }
             
#print func_dict
with open("//wsl.localhost/Ubuntu-20.04/root/Documents/Tesi/Ghidra/outputs/CFG/cfg_onCreate_prova.json", "w") as outfile:
    json.dump(func_dict, outfile)

