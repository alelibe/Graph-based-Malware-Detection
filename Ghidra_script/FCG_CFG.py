#TODO write a description for this script
#@author 
#@category _NEW_
#@keybinding 
#@menupath 
#@toolbar 


from ghidra.program.model.block import BasicBlockModel
from ghidra.util.task import TaskMonitor
from ghidra.util.task import ConsoleTaskMonitor
from ghidra.util.graph import Edge
from ghidra.util.graph import Vertex
import json


def buildCFG(name):
	bbm = BasicBlockModel(currentProgram)
	monitor = ConsoleTaskMonitor()

	funcs = currentProgram.getFunctionManager().getFunctions(True)
	for f in funcs:
		if name in str(f.getName()):
			body = f.getBody()
			

	# creo l'insieme di nodi e di archi
	nodes_cfg, edges_cfg = [], []
	disass = []
	# basic block's features
	bbs_dict = dict()

	blocks = bbm.getCodeBlocksContaining(body, monitor)

	block = blocks.next()
	#memorizzo l'inizio del blocco precedente
	block_prec_start = block.minAddress
	ins_prec = " "
	while block:
		listing = currentProgram.getListing()
	    	ins_iter = listing.getInstructions(block, True)
		
		block_start = block.minAddress
		nodes_cfg.append(str(block_start))
		if ("if" in str(ins_prec) and block_start != block_prec_start):
			edges_cfg.append((str(block_prec_start), str(block_start)))

		if not("if" in str(ins_prec) or "go" in str(ins_prec) or "return" in str(ins_prec)) and block_start != block_prec_start:
			edges_cfg.append((str(block_prec_start), str(block_start)))

		block_prec_start = block.minAddress
		

		# metto l'assemby del blocco in un dict
		#bbs_dict[str(block_start)] = {'disass': disassembly_block(block)}

		ins = ins_iter.next()
		while ins:
			ins_prec = ins
			disass.append(str(ins))
			flows = ins.getFlows()
			#print ins
			#print flows
			if ("if" in str(ins) or "go" in str(ins)) and len(flows) == 1:
				addrSucc = flows[0]
				edges_cfg.append((str(block_start), str(addrSucc)))
				# print "0x{}".format(flows[0])
					# if ins.getAddressString(False, True) == addr :
					# 	print addr

		   	ins = ins_iter.next()
			
			
		bbs_dict[str(block_start)] = {'disass': disass}
		disass = []
		block = blocks.next()


	func_dict = {
	                'nodes': nodes_cfg,
	                'edges': edges_cfg,
	                'basic_blocks': bbs_dict
	            }
	             
	#print func_dict
	filename = "//wsl.localhost/Ubuntu-20.04/root/Documents/Tesi/Ghidra/outputs/CFG/prova_test/cfg_" + name + ".json"
	#print filename
	with open(filename, "w") as outfile:
	    json.dump(func_dict, outfile)




def isFunction(fm,addr):
	bool = fm.isInFunction(addr)

	return bool

def get_jumpFrom(addr):
	refs = getReferencesFrom(addr)
	jump = refs[0]

	return jump

def buildFCG(name):
	listing = currentProgram.getListing()
	fm = currentProgram.getFunctionManager()
	funcs = fm.getFunctions(True)
	for f in funcs:
		if str(f.getName()) in str(name).split("::")[-1]:
			body = f.getBody()
			name_entry = f.getName()
		

	ins_iter = listing.getInstructions(body, True)

	
	while ins_iter.hasNext():
		ins = ins_iter.next()
		if "invoke" in str(ins):
			addr_toJump = get_jumpFrom(ins.getAddress()).getToAddress()
			if isFunction(fm,addr_toJump):
				methodName = str(fm.getFunctionAt(addr_toJump))
			else:
				methodName = str(get_jumpFrom(addr_toJump))[2:]

			if not(methodName in nodes_fcg):
				nodes_fcg.append(methodName)

			if not((name, methodName) in edges_fcg):
				edges_fcg.append((name, methodName))
	

# creo l'insieme di nodi e di archi
nodes_fcg, edges_fcg = [], []
nodes_fcg.append("onCreate")
buildFCG("onCreate")	
name = "onCreate"
i = 0

while i < len(edges_fcg):
	if (name in edges_fcg[i][0]) and not("EXTERNAL" in edges_fcg[i][1]):
		#node = edges_fcg[i][1].split("::")[-1]
		node = edges_fcg[i][1]
		buildFCG(node)

	if not(name in edges_fcg[i][0]):
		name = edges_fcg[i][0].split("::")[-1]
	else:
		i = i + 1
	

for node in nodes_fcg:
	if not("EXT" in node):
		name = node.split("::")[-1]
		buildCFG(name)

fcg_dict = {
                'nodes': nodes_fcg,
                'edges': edges_fcg
            }
             
with open("//wsl.localhost/Ubuntu-20.04/root/Documents/Tesi/Ghidra/outputs/FCG/fcg_test.json", "w") as outfile:
    json.dump(fcg_dict, outfile)




