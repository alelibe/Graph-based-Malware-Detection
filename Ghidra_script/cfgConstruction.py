from ghidra.program.model.block import BasicBlockModel
from ghidra.util.task import TaskMonitor
from ghidra.util.task import ConsoleTaskMonitor
from ghidra.util.graph import Edge
from ghidra.util.graph import Vertex
import json


# def disassembly_block(block):
# 	listing = currentProgram.getListing()
# 	ins_iter = listing.getInstructions(block, True)

# 	# disass = set();
# 	disass = []


# 	while ins_iter.hasNext():
# 		ins = ins_iter.next()
#        		disass.append(ins)
    
# 	return disass


funcName = 'onCreate_android.os.Bundle_void'
bbm = BasicBlockModel(currentProgram)
monitor = ConsoleTaskMonitor()
func = getGlobalFunctions(funcName)[0]

# creo l'insieme di nodi e di archi
nodes_list, edges_list = [], []
disass = []
# basic block's features
bbs_dict = dict()

blocks = bbm.getCodeBlocksContaining(func.getBody(), monitor)

block = blocks.next()
#memorizzo l'inizio del blocco precedente
block_prec_start = block.minAddress
ins_prec = " "
while block:
	listing = currentProgram.getListing()
    	ins_iter = listing.getInstructions(block, True)

  	block_start = block.minAddress
	nodes_list.append(str(block_start))
	if ("if" in str(ins_prec) and block_start != block_prec_start):
		edges_list.append((str(block_prec_start), str(block_start)))

	#seconda condizione serve perchè al primo giro block_start è uguale a block_prec_start
	#e questo significa che ins_prec è ancora uguale a " "
	if not("if" in str(ins_prec) or "go" in str(ins_prec) or "return" in str(ins_prec)) and block_start != block_prec_start:
		edges_list.append((str(block_prec_start), str(block_start)))


	block_prec_start = block.minAddress
	

	# metto l'assemby del blocco in un dict
	#bbs_dict[str(block_start)] = {'disass': disassembly_block(block)}

	ins = ins_iter.next()
	while ins:
		ins_prec = ins
		disass.append(str(ins))
		flows = ins.getFlows()
		if len(flows) == 1:
			addrSucc = flows[0]
			edges_list.append((str(block_start), str(addrSucc)))
			# print "0x{}".format(flows[0])
				# if ins.getAddressString(False, True) == addr :
				# 	print addr

	   	ins = ins_iter.next()
		
	bbs_dict[str(block_start)] = {'disass': disass}
	disass = []
	block = blocks.next()
	

func_dict = {
                'nodes': nodes_list,
                'edges': edges_list,
                'basic_blocks': bbs_dict
            }
             
print func_dict
with open("//wsl.localhost/Ubuntu-20.04/root/Documents/Tesi/Ghidra/outputs/CFG/cfg_isMyServiceRunning.json", "w") as outfile:
    json.dump(func_dict, outfile)